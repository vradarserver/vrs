// Copyright © 2023 onwards, Andrew Whewell
// All rights reserved.
//
// Redistribution and use of this software in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
//    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
//    * Neither the name of the author nor the names of the program's contributors may be used to endorse or promote products derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OF THE SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

using System.Text;
using System.Text.RegularExpressions;
using VirtualRadar.Interface.Types;

namespace VirtualRadar.Interface
{
    /// <summary>
    /// Describes a log message that's either been loaded from the log file or generated
    /// within this session.
    /// </summary>
    public class LogMessage
    {
        // Used to lock properties and fields on the object
        private readonly object _SyncLock = new();

        /// <summary>
        /// A regular expression that will match the first line of a log message generated by this class.
        /// </summary>
        public static readonly Regex FirstLineRegex = new(@"^\[(?<date>\d{4}-\d{2}-\d{2}) (?<time>\d{2}:\d{2}:\d{2}\.\d{3}) UTC\] \[t(?<threadIds>[\d\,]+)\] (<?msg>.*)$");

        /// <summary>
        /// A regular expression that matches a follow-on line generated by this class.
        /// </summary>
        public static readonly Regex FollowOnLineRegex = new(@"^+ (?<line>.*)$");

        /// <summary>
        /// The message ID. This is assigned when the line is created and never changes.
        /// It is a sequentially assigned value starting from 0.
        /// </summary>
        public long InstanceId { get; }

        /// <summary>
        /// The revision ID. This starts at 0 and gets updated whenever the count of
        /// instances is incremented.
        /// </summary>
        public long RevisionId { get; private set; }

        /// <summary>
        /// The text message. Old session messages will include the log time and thread ID.
        /// </summary>
        public string Text { get; private set; }

        private volatile List<int> _FromThreadIds = new();
        /// <summary>
        /// Empty if this is an old message loaded from the log file, otherwise the ID of every
        /// thread that has logged this message.
        /// </summary>
        public IReadOnlyList<int> FromThreadIds
        {
            get {
                var result = _FromThreadIds;
                return result;
            }
        }

        /// <summary>
        /// Null if this is an old message loaded from the log file, otherwise the time at UTC
        /// when the message was first logged.
        /// </summary>
        public DateTime? FirstLoggedAtUtc { get; }

        /// <summary>
        /// The last time the message was logged.
        /// </summary>
        public DateTime? LastLoggedAtUtc { get; private set; }

        /// <summary>
        /// The number of seconds elapsed between <see cref="FirstLoggedAtUtc"/> and <see cref="LastLoggedAtUtc"/>.
        /// </summary>
        public double ElapsedSeconds => IsFromPreviousSession
            ? 0
            : (DateTimeHelper.Max(LastLoggedAtUtc.Value, FirstLoggedAtUtc.Value) - FirstLoggedAtUtc.Value).TotalSeconds;

        /// <summary>
        /// The average number of instances recorded per second.
        /// </summary>
        public double InstancesPerSecond => ElapsedSeconds / CountInstances;

        /// <summary>
        /// The number of times the message has been logged recently.
        /// </summary>
        public long CountInstances { get; private set; }

        /// <summary>
        /// True if this is an old log message loaded from the log file.
        /// </summary>
        public bool IsFromPreviousSession => FirstLoggedAtUtc == null;

        /// <summary>
        /// Creates a new object.
        /// </summary>
        /// <param name="instanceId"></param>
        /// <param name="text"></param>
        /// <param name="loggedAt"></param>
        /// <param name="fromThreadId"></param>
        public LogMessage(long instanceId, string text, DateTime? loggedAt, int? fromThreadId)
        {
            InstanceId = instanceId;
            Text = text ?? "";
            FirstLoggedAtUtc = loggedAt;
            LastLoggedAtUtc = FirstLoggedAtUtc;
            if(fromThreadId != null) {
                _FromThreadIds.Add(fromThreadId.Value);
            }
            CountInstances = 1;
        }

        /// <summary>
        /// Creates a new object.
        /// </summary>
        /// <param name="instanceId"></param>
        /// <param name="text"></param>
        public LogMessage(long instanceId, string text) : this(instanceId, text, null, null)
        {
        }

        /// <summary>
        /// Creates a deep copy.
        /// </summary>
        /// <param name="other"></param>
        public LogMessage(LogMessage other)
        {
            lock(other._SyncLock) {
                _FromThreadIds = new(other.FromThreadIds);
                CountInstances = other.CountInstances;
                FirstLoggedAtUtc = other.FirstLoggedAtUtc;
                LastLoggedAtUtc = other.LastLoggedAtUtc;
                RevisionId = other.RevisionId;
                Text = other.Text;
            }
        }

        /// <summary>
        /// Creates a deep copy clone.
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public static LogMessage Clone(LogMessage other) => new(other);

        /// <summary>
        /// See base docs.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            var result = new StringBuilder();

            if(IsFromPreviousSession || Text.Length == 0) {
                var lines = Text.SplitIntoLines();
                for(var lineIdx = 0;lineIdx < lines.Count;++lineIdx) {
                    var line = lines[lineIdx];
                    if(lineIdx + 1 < lines.Count) {
                        result.AppendLine(line);
                    } else {
                        result.Append(line);
                    }
                }
            } else {
                lock(_SyncLock) {
                    result.Append($"[{FirstLoggedAtUtc:yyyy-MM-dd HH:mm:ss.fff} UTC] ");
                    result.Append($"[t{String.Join(",", FromThreadIds.Select(tid => tid.ToString()))}] ");

                    var lines = Text.SplitIntoLines();
                    for(var lineIdx = 0;lineIdx < lines.Count;++lineIdx) {
                        if(lineIdx > 0) {
                            result.AppendLine();
                            result.Append("+ ");
                        }
                        result.Append(lines[lineIdx]);
                    }

                    if(CountInstances > 1) {
                        result.AppendLine();
                        result.Append($"+ (Last message seen {CountInstances} times in {ElapsedSeconds:N1} seconds, averaging {InstancesPerSecond:N1}/sec)");
                    }
                }
            }

            return result.ToString();
        }

        /// <summary>
        /// Increments counters to indicate that a new instance of the message has been seen.
        /// </summary>
        /// <param name="utcNow"></param>
        /// <param name="threadId"></param>
        /// <exception cref="InvalidOperationException">Thrown if this entry was not generated in this session.</exception>
        public void AddInstance(DateTime utcNow, int threadId)
        {
            if(IsFromPreviousSession) {
                throw new InvalidOperationException($"An attempt was made to change the instance count on a message from a previous session");
            }

            lock(_SyncLock) {
                ++CountInstances;
                LastLoggedAtUtc = utcNow;
                if(!_FromThreadIds.Contains(threadId)) {
                    _FromThreadIds = new List<int>(_FromThreadIds) {
                        threadId
                    };
                }
                ++RevisionId;
            }
        }

        /// <summary>
        /// Appends a line of text to the message.
        /// </summary>
        /// <param name="text"></param>
        public void AppendLine(string text)
        {
            lock(_SyncLock) {
                Text = $"{Text}{Environment.NewLine}{text}";
                ++RevisionId;
            }
        }
    }
}
